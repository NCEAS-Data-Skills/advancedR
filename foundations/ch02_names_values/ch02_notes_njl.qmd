---
title: "Chapter 2: Names & Values -- Notes"
author: "Nick J Lyon"
format: html
engine: knitr
code-overflow: wrap
---

```{r libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(lobstr)
```

## 2.2 Binding Basics

Objects are not the same as their names. In the following code, two things are happening: (1) an object is created that is a vector of values and (2) that object is bound to the name `x`.

```{r 02-bind-note_make-obj}
x <- c(1, 2, 3)
```

Names can be thought of as references to a particular value. If you run the following code _you do not get another copy of the value,_ instead <u>you get another binding to the existing object</u>.

```{r 02-bind-note_copy-obj}
y <- x
```

We can confirm this by checking both objects' "memory addresses". These are the unique identifiers indicating where in the computer's memory a particular object is stored. This uses functions from the `lobstr` package.

We can see in the following code that even though the objects have different names, they have the same memory address.

```{r 02-bind-note_check-mem-address}
lobstr::obj_addr(x = x)
lobstr::obj_addr(x = y)
```

Note that R strictly enforces the use of **syntactic names**. These are names that consist of some combination of letters, numbers, `.`, and/or `_` (but do not begin with `.` or `_`). Also there are certain <u>reserved words</u> (e.g., `TRUE`, `NULL`, `function`, etc.) that are not valid names even though they are comprised of valid characters. A full list of these reserved names can be returned by running `?Reserved`.

These rules can be overridden by surrounding the desired name with backticks (\`) but doing so is cumbersome in the long run.

## 2.3 Copy-on-Modify

Anyone who has worked with R has noticed that when you create a new object by modifying an existing one, you don't affect the original one. This is because of R's **copy-on-modify** behavior, where R creates a copy of the first object then binds it to the new name. This might be paraphrased as R's objects being _immutable_, though their are exceptions.

Note that this is an important difference from `fontawesome::fa(name = "python", a11y = "sem")` Python's default behavior. `fontawesome::fa(name = "python", a11y = "sem")` Python requires you to use the `.copy()` method or changes to a downstream object affect the values bound to the original name.

### 2.3.1 `tracemem()`

In R, we can trace when a given object is copied (and from what) using the `base::tracemem()` function. Note this doesn't work as expected in RStudio so you'll need to use the Terminal or R directly to experiment. Also, remember to use `base::untracemem()` when you're done to stop getting the memory address / object history for every line of code!

### 2.3.3 Lists

Instead of storing the values themselves, each element of a list stores references to the values it "contains". This means that modifying one element of a list means that the unchanged elements of both lists (old and new) share memory addresses with their counterpart in the other list while the changed elements have different memory addresses. There's a really nice diagram of this in [Section 2.3.3](https://adv-r.hadley.nz/names-values.html#list-references).

We can use `lobstr::ref()` to demonstrate this. Note how the two lists have different memory addresses as a whole but the first two elements (i.e., the unchanged ones) _share_ memory addresses but the final memory address (i.e., the modified one) differs between the two lists.

```{r 02-copy-mod-note_list-mem-address}
# Make two lists (one is a copy of the other)
l1 <- list(1, 2, 3)
l2 <- l1

# Modify one element of the copy
l2[[3]] <- 4

# Check the memory addresses of all elements of both lists
lobstr::ref(l1)
lobstr::ref(l2)
```

### 2.3.4 Dataframes

Dataframes are lists of vectors (i.e., columns) which has an important consequence for copy-on-modify and where in computer memory objects are stored. If you modify a _column_ only that column needs a new object in computer memory. However, if you modify a _row_, **every** column is modified and all must be stored as new objects.

### 2.3.5 Character Vectors

R stores characters in a **global string pool** where each element of a character vector is a pointer to a unique string in the pool. We can check this with `lobstr::ref()`--just like we can check lists--but we have to set the `character` argument to `TRUE`.

```{r 02-copy-mod-note_char-mem-address}
# Make vector
my_char <- c("a", "a", "abc", "d")

# Check memory addresses
lobstr::ref(my_char, character = TRUE)
```

## 2.4 Object Size

You can see how much memory an object takes with `lobstr::obj_size()`.

```{r 02-size-note_check}
obj_size(letters)
```

Because lists contain references to values (rather than the values themselves), they are often _much_ smaller than you might think!

```{r 02-size-note_list}
# Bind some values to a name
x <- runif(n = 1e6)

# Make a list of duplicates of that object
y <- list(x, x, x)

# Check size of both and see they are basically the same
lobstr::obj_size(x); lobstr::obj_size(y)
```

Because of R's global string pool (see the 'character vectors' bit of the "Copy-on-Modify" section), characters also take up less space than you might expect.

Finally, R (>= `3.5.0`) also uses "ALTREP" which is short for **alternative representation**. This means that numeric ranges are stored as simply the first and last number. Memory storage-wise it means that no matter how wide of a range is bound to an object, they all take up the same amount of memory.

```{r 02-size-note_altrep}
lobstr::obj_size(1:3)
lobstr::obj_size(1:1e9)
```

## 2.5 Modify-in-Place

There are some exceptions to copy-on-modify, namely:

1. Objects with a single binding get a special performance optimization
2. Environments (which are a special type of object) are always modified in place

### 2.5.1 Single Binding Objects

Let's explore an example. We'll subtract the median from each column of a very large dataframe.

```{r 02-mod-place-note_demo-slow}
x <- data.frame(matrix(runif(5 * 1e4), ncol = 5))
medians <- vapply(x, median, numeric(1))

cat(tracemem(x), "\n")

for (i in 1:5) {
  x[[i]] <- x[[i]] - medians[[i]]
}

untracemem(x)
```

If we convert the dataframe to a list we find that far fewer copies are produced and subsequently the loop is _much_ faster.

```{r 02-mod-place-note_demo-fast}
y <- as.list(x)

cat(tracemem(y), "\n")

for (i in 1:5) {
  y[[i]] <- y[[i]] - medians[[i]]
}

untracemem(x)
```

### 2.5.2 Environments

Environments are always modified in place. This is sometimes called "**reference semantics**" because when you modify an environment, all existing bindings to that environment continue to have the same reference.

Environments can also refer to themselves (which is a unique property of environments).

## 2.6 Unbinding & Garbage Collector

When you use `rm()` you only remove the _names_ bound to the objects, not the objects themselves. This means that at the end of your code you might have many objects in your computer memory that have no names.

We can remove such objects with the **garbage collector** (a.k.a. "GC"). R uses a <u>tracing</u> GC which means that every object reachable from the global environment and the objects reachable from those objects (and so on). The GC does not use the modify-in-place reference count we covered above.

It is impossible to know when the GC will run itself (though it does happen automatically) and there is no need to run it manually (via `gc()`) unless you want to ask R to set aside memory for non-R programs and/or for the side-effect that it tells you how much memory is currently being used.

In that latter case, you could use `lobstr::mem_used()` to get the number of bytes currently being used. Though this number will differ from the amount of memory reported by your OS because (1) it includes objects created by R but not the R interpreter, (2) R might be 'holding on to' memory that the OS hasn't asked to be returned, and (3) R counts memory occupied by objects but there may be empty gaps due to deleted objects (phenomenon known as "memory fragmentation").
