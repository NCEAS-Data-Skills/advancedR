---
title: "Chapter 6: Functions -- Notes & Exercises"
author: "Nick J Lyon"
format: html
engine: knitr
code-overflow: wrap
---

```{r libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(purrr)
```

```{scss custom-themes, echo=FALSE}
.answer { 
  color: #560bad;
  font-weight: bolder;
}
```

## 6.2 Function Fundamentals

Functions are fundamentally composed of (1) arguments, (2) body, and (3) environment. _Except_ primitive functions implemented purely in C.

### 6.2.1 Function Components

Can check arguments, body, and environment with `formals()`, `body()`, and `environment()` respectively.

### 6.2.2 Primitive Functions

Primitive functions have type "builtin" or "special".

```{r 06-fundament_primitives}
typeof(x = sum)
typeof(x = `[`)
```

Primitive functions are faster but at the cost of interpretability (both reading and writing).

### 6.2.3 First-Class Functions

R functions are objects in and of themselves (this is known as "first-class functions"). While some other languages have special conventions for creating functions, R supports simple assignment as with all other objects--albeit with structural requirements for the function to _be_ a function and work as intended.

You can create functions without binding them to a name (resulting in "anonymous functions") or add functions to a list and then invoke them with `list_obj$fxn_name(arguments)`

### 6.2.4 Invoking a Function

You can invoke a function by putting values inside of function parentheses (with or without naming arguments) or by storing the arguments in a data structure and using `do.call()` on that. For example:

```{r 06-fundament_invoke}
args_list <- list(1:10, na.rm = T)

do.call(what = mean, args = args_list)
```

### 6.2.5 Exercises

1. Given a name, like `"mean"`, `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn't this make sense in R?

[It is not clear what "given a function" means other than the name of a function. Also, just practically, if you had 'the function' why would you need to find it?]{.answer}

2. It's possible (though typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{.r 06-fundament_q2}
function(x) 3()
(function(x) 3)()
```

[The second approach is correct. In the second instance, essentially a nameless function that returns `3` is created (see the wrapping parentheses starting in the first character) and then invoked (via the empty parentheses at the end). The second instance seems to be treating `3` as a function name in and of itself (based on the fact it is adjacent to empty parentheses).]{.answer}

3. A good rule of thumb is that an anonymous function should fit on one line and shouldn't need to use `{}`. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

[I don't use anonymous functions nor do I intend to as their use-case / benefit over named functions is unclear to me. I suppose simple arithmetic / `apply`-style iterative code could make use of anonymous functions.]{.answer}

4. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

[The `class` function will tell you whether an object is a function. The `typeof` function will tell you (implicitly) whether a function is primitive of not because primitive functions are all of type "builtin" or "special".]{.answer}

5. This code makes a list of all functions in the base package. Use it to answer the following questions:

```{r 06-fundament_q5}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

> (A) Which base function has the most arguments?

[The `scan` function has the most arguments with 22! See below.]{.answer}

```{r 06-fundament_a5-A}
# Identify number of arguments / functions
arg_ct <- purrr::map_int(.x = funs, .f = ~ length(formals(.x)))

# Identify highest argument count
sort(x = arg_ct)[length(arg_ct)]
```

> (B) How many base functions have no arguments? What's special about those functions?

[48 functions have no arguments. See below. Note that I did need to check the answer and did not know to remove primitive functions beforehand (stating that here in the spirit of transparency).]{.answer}

```{r 06-fundament_a5-B}
# Remove primitive functions from list
non_prim_funs <- purrr::discard(.x = funs, .p = is.primitive)

# Count arguments of remaining
non_prim_arg_ct <- purrr::map_int(.x = non_prim_funs, .f = ~ length(formals(.x)))

# Identify number of non-primitive functions without arguments
sum(non_prim_arg_ct == 0, na.rm = T)
```

> (C) How could you adapt the code to find all primitive functions?

[There are 210 primitive functions. We can simply change `discard()` in our answer to 5B to `keep()` and we'll be left with a list of only primitive functions.]{.answer}

```{r 06-fundament_a5-C}
# Identify *only* primitive functions
prim_funs <- purrr::keep(.x = funs, .p = is.primitive)

# Count 'em up
length(prim_funs)
```

6. What are the three important components of a function?

[They are the function's arguments, its body, and its environment. See notes above for how to access this information.]{.answer}

7. When does printing a function not show the environment it was created in?

[Primitive functions and those not from a package (i.e., those created in the global environment), do not display their environment.]{.answer}

## 6.3 Function Composition

Can nest functions inside progressively more parentheses pairs or create intermediary objects to store results. Can also use `magrittr`'s `%>%` to chain together operations.

| Composition Type | Example | Advantage(s) | Disadvantage(s) |
|:---:|:---:|:---:|:---:|
| Nesting | `g(f(x))` | Concise; well-suited for short operations | Hard to read because of inside-outside and left-right order of operations |
| Intermediate Objects | `obj1 <- f(x); obj2 <- g(obj1)` | Valuable if intermediary objects are valuable in and of themselves; also nice for debugging / actively developing code workflow | Naming required for intermediary objects |
| Piping | `x %>% f() %>% g()` | Order of operations is more intuitive; no intermediary objects | Only works with linear transformations of a single object; requires a 3^rd^ party package and literacy of that package in code readers |

## 6.4 Lexical Scoping

"Scoping" = finding value associated with name. R uses "**lexical scoping**" in that it looks for values of names based on how a function is defined, not how it is called in a particular context. There are four primary rules discussed below.

### 6.4.1 Scoping Rule 1: Name Masking

Essentially, names defined _inside_ of function "mask" objects with the same name created outside of the function. So if you have an `x` object and the function internally creates an `x` object, it won't consider your prior `x` object.

However, if an object is named inside of a function but not defined there / supplied to an argument, R will look one level up for an object of that name, all the way--eventually--to the global environment.

### 6.4.2 Scoping Rule 2: Functions vs. Variables

Because functions are just another type of object, the name masking rules apply to functions as well. I.e., if a function is defined inside of another function (and shares a name with a function created outside of the nested one), the internally-created function will be prioritized.

R however does not mix up non-function objects and function objects so if a function and non-function share a name, R will use each correctly.

Note that it is bad practice to name objects (functions or otherwise) identically in your own code because it makes it hard to read / for novices to interpret.

### 6.4.3 Scoping Rule 3: Fresh Start

Each use of a function is done in a completely different environment so that each function will behave predictably (as opposed to potentially being affected by prior uses of the same/other functions).

### 6.4.4 Scoping Rule 4: Dynamic Lookup

R looks for values when the function is **run**, _not_ when it is defined! So you can define a function and then define variables for it to use (see the name masking rule) and when you use the function it should work.

Note that this means you won't actually get an error for typos / issues with your functions until you use them which can be a pain for debugging. Consider `findGlobals()` to identify external dependencies (i.e., unbound symbols) within a function.

### 6.4.5 Exercises

1. What does the following code return? Why? Describe how each of the three `c`'s is interpreted.

```{r 06-scoping_q1}
#| eval: false

c <- 10
c(c = c)
```

[This code should return a named vector of length one. The value should be 10 and the name should be "c". The first `c` invokes the combine function, the `c` on the left of the equal sign specifies the name attribute for the value while the `c` on the right of the equal sign specifies the value bound in the object created above the line with three `c`'s.]{.answer}

2. What are the four principles that govern how R looks for values?

[They are all part of R's "lexical scoping" and they include (1) name masking, (2) functions vs. variables, (3) fresh start, and (4) dynamic lookup]{.answer}

3. What does the following function return? Make a prediction before running the code yourself.

[I think the code will return `202` because it will first square the provided `x`, then add 1, then multiply by 2. In effect the `10` supplied to the largest function (i.e., the one that contains the others) is passed all the way to the deepest function then the code runs from inside to outside. See the 'name masking' lexical scoping rule in particular.]{.answer}

```{r 06-scoping_q3}
f <- function(x) {
  f <- function(x) {
    f <- function() {
      x ^ 2
    }
    f() + 1
  }
  f(x) * 2
}
f(10)
```

## 6.5 Lazy Evaluation


## 6.6 `...` (Ellipsis)


## 6.7 Exiting a Function



## 6.8 Function Forms







