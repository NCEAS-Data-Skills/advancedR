---
title: "Chapter 6: Functions -- Notes & Exercises"
author: "Nick J Lyon"
format: html
engine: knitr
code-overflow: wrap
---

```{r libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(purrr)
```

```{scss custom-themes, echo=FALSE}
.answer { 
  color: #560bad;
  font-weight: bolder;
}
```

## 6.2 Function Fundamentals

Functions are fundamentally composed of (1) arguments, (2) body, and (3) environment. _Except_ primitive functions implemented purely in C.

### 6.2.1 Function Components

Can check arguments, body, and environment with `formals()`, `body()`, and `environment()` respectively.

### 6.2.2 Primitive Functions

Primitive functions have type "builtin" or "special".

```{r 06-fundament_primitives}
typeof(x = sum)
typeof(x = `[`)
```

Primitive functions are faster but at the cost of interpretability (both reading and writing).

### 6.2.3 First-Class Functions

R functions are objects in and of themselves (this is known as "first-class functions"). While some other languages have special conventions for creating functions, R supports simple assignment as with all other objects--albeit with structural requirements for the function to _be_ a function and work as intended.

You can create functions without binding them to a name (resulting in "anonymous functions") or add functions to a list and then invoke them with `list_obj$fxn_name(arguments)`

### 6.2.4 Invoking a Function

You can invoke a function by putting values inside of function parentheses (with or without naming arguments) or by storing the arguments in a data structure and using `do.call()` on that. For example:

```{r 06-fundament_invoke}
args_list <- list(1:10, na.rm = T)

do.call(what = mean, args = args_list)
```

### 6.2.5 Exercises

1. Given a name, like `"mean"`, `match.fun()` lets you find a function. Given a function, can you find its name? Why doesn't this make sense in R?

[It is not clear what "given a function" means other than the name of a function. Also, just practically, if you had 'the function' why would you need to find it?]{.answer}

2. It's possible (though typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{.r 06-fundament_q2}
function(x) 3()
(function(x) 3)()
```

[The second approach is correct. In the second instance, essentially a nameless function that returns `3` is created (see the wrapping parentheses starting in the first character) and then invoked (via the empty parentheses at the end). The second instance seems to be treating `3` as a function name in and of itself (based on the fact it is adjacent to empty parentheses).]{.answer}

3. A good rule of thumb is that an anonymous function should fit on one line and shouldn't need to use `{}`. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

[I don't use anonymous functions nor do I intend to as their use-case / benefit over named functions is unclear to me. I suppose simple arithmetic / `apply`-style iterative code could make use of anonymous functions.]{.answer}

4. What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

[The `class` function will tell you whether an object is a function. The `typeof` function will tell you (implicitly) whether a function is primitive of not because primitive functions are all of type "builtin" or "special".]{.answer}

5. This code makes a list of all functions in the base package. Use it to answer the following questions:

```{r 06-fundament_q5}
#| eval: false

objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

> (A) Which base function has the most arguments?

[The `scan` function has the most arguments with 22! See below.]{.answer}

```{r 06-fundament_a5-A}
# Identify number of arguments / functions
arg_ct <- purrr::map_int(.x = funs, .f = ~ length(formals(.x)))

# Identify highest argument count
sort(x = arg_ct)[length(arg_ct)]
```

> (B) How many base functions have no arguments? What's special about those functions?

[48 functions have no arguments. See below. Note that I did need to check the answer and did not know to remove primitive functions beforehand (stating that here in the spirit of transparency).]{.answer}

```{r 06-fundament_a5-B}
# Remove primitive functions from list
non_prim_funs <- purrr::discard(.x = funs, .p = is.primitive)

# Count arguments of remaining
non_prim_arg_ct <- purrr::map_int(.x = non_prim_funs, .f = ~ length(formals(.x)))

# Identify number of non-primitive functions without arguments
sum(non_prim_arg_ct == 0, na.rm = T)
```

> (C) How could you adapt the code to find all primitive functions?

[There are 210 primitive functions. We can simply change `discard()` in our answer to 5B to `keep()` and we'll be left with a list of only primitive functions.]{.answer}

```{r 06-fundament_a5-C}
# Identify *only* primitive functions
prim_funs <- purrr::keep(.x = funs, .p = is.primitive)

# Count 'em up
length(prim_funs)
```

6. What are the three important components of a function?

[They are the function's arguments, its body, and its environment. See notes above for how to access this information.]{.answer}

7. When does printing a function not show the environment it was created in?

[Primitive functions and those not from a package (i.e., those created in the global environment), do not display their environment.]{.answer}

## 6.3 Function Composition



## 6.4 Lexical Scoping



## 6.5 Lazy Evaluation


## 6.6 `...` (Ellipsis)


## 6.7 Exiting a Function



## 6.8 Function Forms







