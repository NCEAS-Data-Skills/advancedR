---
title: "Chapter 6: Functions -- Notes & Exercises"
author: "Casey O'Hara"
format: 
  html:
    toc: true
    embed-resources: true
engine: knitr
execute:
  warning: !expr NA ### suppresses warnings when rendering, but not in interactive mode
  message: !expr NA
code-overflow: wrap
editor: source
---

## Setup


```{r libs, echo = FALSE}
### just here so the shortcut doesn't create a scss chunk
```

```{scss custom-themes, echo=FALSE}
.answer { 
  color: #560bad;
  font-weight: bolder;
}
```

# 6 Functions

From [Chapter 6](https://adv-r.hadley.nz/functions.html#functions) in the second edition of [Advanced R](https://adv-r.hadley.nz/index.html) by Hadley Wickham.

Answers for all exercises can be found in [Chapter 5](https://advanced-r-solutions.rbind.io/functions) in the second edition of [Advanced R Solutions](https://advanced-r-solutions.rbind.io/)

## 6.2 Function Fundamentals

### 6.2.1 Function components

Three components:

* `formals()` - the list of arguments
* `body()` - code inside the function
* `environment()` - the data structure that determines how the function finds the values associated with the names

```{r}
#| eval: false

f02 <- function(x, y) {
  # A comment
  x + y
}

formals(f02)
#> $x
#> 
#> 
#> $y

body(f02)
#> {
#>     x + y
#> }

environment(f02)
#> <environment: R_GlobalEnv>
```

Functions can contain attributes, incl `srcref`, the source reference, points to the source code used to create the function.

```{r}
f02 <- function(x, y) {
  # A comment
  x + y
}

attr(f02, 'srcref')
```

### 6.2.2 Primitive functions

These call C code directly.  Examples: `sum()`, `[`.  They have type `builtin` or `special`, and `formals()`, `body()`, and `environment()` all `NULL` b/c they live in C, not R.

```{r}
#| eval: false

sum
#> function (..., na.rm = FALSE)  .Primitive("sum")
`[`
#> .Primitive("[")

typeof(sum)
#> [1] "builtin"
typeof(`[`)
#> [1] "special"

formals(sum)
#> NULL
body(sum)
#> NULL
environment(sum)
#> NULL
```

### 6.2.3 First-class functions

R functions are objects, a language property often called "first-class functions."  No special syntax for defining and naming (as in Matlab or C), just regular R code like any other object.

If you don't bind it to a name, it is an anonymous function (e.g., inside `lapply()`)

### 6.2.4 Invoking a function

Regular: function name, and place the arguments into appropriate places, wrapped in parentheses...

Other option: arguments already in a data structure e.g. a `list`: instead, use `do.call()` - the function to call, and the list containing the function arguments.

```{r}
args <- list(x = 1:10, na.rm = TRUE)

do.call(what = mean, args = args)
```


### 6.2.5 Exercises

1.  Given a name, like `"mean"`, [`match.fun()`](https://rdrr.io/r/base/match.fun.html) lets you find a function. Given a function, can you find its name? Why doesn't that make sense in R?

>[A function could be represented by multiple names, or even none (anonymous), but each name can only represent a single function.  Relationship between name and object is clearly defined only in one direction.  Example code from the answer key:]{.answer}

```{r}
function(x) sd(x) / mean(x)
#> function(x) sd(x) / mean(x)

f1 <- function(x) (x - min(x)) / (max(x) - min(x))
f2 <- f1
f3 <- f1
```

>[Not exactly sure how this is useful, however...]{.answer}

2.  It's possible (although typically not useful) to call an anonymous function. Which of the two approaches below is correct? Why?

```{r}         
function(x) 3()
#> function(x) 3()
(function(x) 3)()
#> [1] 3
```

>[The second is correct.  The first defines a function that takes x, and returns the result of the function `3()`, which is an invalid name.  The second creates a function that takes x, and returns 3; the second set of parentheses call the function.  If you wrap the first in parens, and then include a second set (to call it), you get an error, attempt to apply non-function (i.e., the function `3()`)]{.answer}


3.  A good rule of thumb is that an anonymous function should fit on one line and shouldn't need to use `{}`. Review your code. Where could you have used an anonymous function instead of a named function? Where should you have used a named function instead of an anonymous function?

>[For simple cases with obvious results (e.g., FUN = function(f) read_csv(f)), you could use an anonymous function (or better, FUN = read_csv, but who's counting?) Named functions should be used for complex cases where the function is not immediately clear.]{.answer}


4.  What function allows you to tell if an object is a function? What function allows you to tell if a function is a primitive function?

>[`class()` tells whether something is a function; `typeof` will return closure for a first-class function and `builtin` or `special` for primitives.  Also, `is.function()` and `is.primitive()`...]{.answer}


5.  This code makes a list of all functions in the base package.

```{r}         
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

  Use it to answer the following questions:

   a.  Which base function has the most arguments?
    
  >[map the list to the `formals()` function, and calc the length of each element, then find the longest element; then use logical subsetting to find the matching original element.]{.answer}
  
```{r}
fun_l <- sapply(funs, FUN = function(x) length(formals(x)))
max_fun <- funs[which(fun_l == max(fun_l))]
names(max_fun)

### OR ###

which(fun_l == max(fun_l)) ### tells the index, and also the name
```
  

    b.  How many base functions have no arguments? What's special about those functions?
    
```{r}
length(which(fun_l == 0))
```
    
  > [260 functions have no arguments... some of these are primitives b/c formal() returns NULL (length 0) for primitives.]{.answer}

    c.  How could you adapt the code to find all primitive functions?
```{r}
fun_prim <- sapply(funs, FUN = is.primitive)

prims <- which(fun_prim)
head(names(prims)); length(prims)
```

  >[apply is.primitive across the functions to get the indices (and names) of them.]{.answer}

6.  What are the three important components of a function?

>[Arguments (`formals()`), body code (`body()`), and environment (`environment()`).  EXCEPT FOR PRIMITIVES.]{.answer}

7.  When does printing a function not show the environment it was created in?

```{r}
mean

f3
```

>[Functions created in the global env don't print their environment; also, neither do primitives (because they're in C world, not R world).]{.answer}


## 6.3 Function Composition



For sequences of multiple calls to functions, three ways:

* Nesting (`f(g(x))`) is concise and ok for short sequences, but complicated and hard to read for long sequences.
* Intermediate objects (`y <- f(x); g(y)`) is ok if intermediate objects can be useful, but when truly intermediate kind of annoying.
* Piping (`x %>% f() %>% g()`) is readable, but requires an extra package (not any more!) and assumes reader understand piping.

## 6.4 Lexical Scoping


### 6.4.1 Name masking


### 6.4.2 Functions versus variables


### 6.4.3 A fresh start


### 6.4.4 Dynamic lookup


### 6.4.5 Exercises


1.    What does the following code return? Why? Describe how each of the three c's is interpreted.

```{r}
c <- 10
c(c = c)
```

>[Creates a named vector, with name "c" and value 10.  The first c is interpreted as the function `c`, which combines objects to make vectors; when a name is used in a function call (as in `c()`) R ignores non-function objects to find the proper match.  The second c is the named part of the named vector.  The third assigns the value `c (=10)` to the vector.]{.answer}


2.   What are the four principles that govern how R looks for values?

>[Name masking - names created inside functions mask names created outside those functions.  Functions vs variables - if a function and value share the same name (diff envts) then if name used as a function call, ignores non-function objects.  Fresh start - each subsequent invocation of a function "forgets" the values in the previous one (the temp environment disappears along with all values inside it!).  And dynamic lookup - R looks for values when an object is run, not when the function is created.  This can be problematic if the function depends on values in an envt "above" the function environment - e.g., in GlobalEnv - that change.  Use `codetools::findGlobals()` to find external dependencies within a function!]{.answer}


3.  What does the following function return? Make a prediction before running the code yourself.

```{r}
f <- function(x) {    ### f_1
  f <- function(x) {  ### f_2
    f <- function() { ### f_3
      x ^ 2
    }
    f() + 1           ### 2. call f_3
  }
  f(x) * 2            ### 1. call f_2
}
f(10)
```


>[Prediction: `f(10)` in global env passes 10 (in envt 1) to `f(10) * 2`.  But that `f(10)` holds x = 10 in envt 2 and calls f() + 1.  That, in turn, takes the x = 10 from envt 2 into envt 3, squares it, and returns 100 to f() in envt 2, where + 1 happens, and 101 is returned to f(x) in envt 1, where it's multiplied by 2 and then that result is returned up to the global envt.  So the result is 202.  And it checks out!]{.answer}


## 6.5 Lazy Evaluation

### 6.5.1 Promises


### 6.5.2 Default arguments


### 6.5.3 Missing arguments


### 6.5.4 Exercises

1.    What important property of `&&` makes `x_ok()` work?

```{r}
x_ok <- function(x) {
  !is.null(x) && length(x) == 1 && x > 0
}

x_ok(NULL)
#> [1] FALSE
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE
```

>[]{.answer}


What is different with this code? Why is this behaviour undesirable here?

```{r}
x_ok <- function(x) {
  !is.null(x) & length(x) == 1 & x > 0
}

x_ok(NULL)
#> logical(0)
x_ok(1)
#> [1] TRUE
x_ok(1:3)
#> [1] FALSE FALSE FALSE
```

>[]{.answer}


2.    What does this function return? Why? Which principle does it illustrate?

```{r}
f2 <- function(x = z) {
  z <- 100
  x
}
f2()
```

>[]{.answer}


3.    What does this function return? Why? Which principle does it illustrate?

```{r}
y <- 10
f1 <- function(x = {y <- 1; 2}, y = 0) {
  c(x, y)
}
f1()
y
```

>[]{.answer}


4.    In `hist()`, the default value of `xlim` is `range(breaks)`, the default value for breaks is `"Sturges"`, and
```{r}
range("Sturges")
#> [1] "Sturges" "Sturges"
```

Explain how `hist()` works to get a correct `xlim` value.

>[]{.answer}


5.    Explain why this function works. Why is it confusing?

```{r}
show_time <- function(x = stop("Error!")) {
  stop <- function(...) Sys.time()
  print(x)
}
show_time()
#> [1] "2021-02-21 19:22:36 UTC"
```

>[]{.answer}

6.    How many arguments are required when calling `library()`?

>[]{.answer}



## 6.6 `...` (dot-dot-dot)

### 6.6.1 Exercises

1.    Explain the following results:

```{r}
sum(1, 2, 3)
#> [1] 6
mean(1, 2, 3)
#> [1] 1

sum(1, 2, 3, na.omit = TRUE)
#> [1] 7
mean(1, 2, 3, na.omit = TRUE)
#> [1] 1
```

>[]{.answer}


2.    Explain how to find the documentation for the named arguments in the following function call:

```{r}
plot(1:10, col = "red", pch = 20, xlab = "x", col.lab = "blue")
```

>[]{.answer}


3.    Why does `plot(1:10, col = "red")` only colour the points, not the axes or labels? Read the source code of `plot.default()` to find out.

>[]{.answer}


## 6.7 Exiting a Function


### 6.7.1 Implicit versus explicit returns



### 6.7.2 Invisible values



### 6.7.3 Errors



### 6.7.4 Exit handlers



### 6.7.5 Exercises

1.    What does `load()` return? Why don't you normally see these values?

>[]{.answer}

2.    What does `write.table()` return? What would be more useful?

>[]{.answer}

3.    How does the chdir parameter of `source()` compare to `with_dir()`? Why might you prefer one to the other?

>[]{.answer}

4.    Write a function that opens a graphics device, runs the supplied code, and closes the graphics device (always, regardless of whether or not the plotting code works).

>[]{.answer}

5.    We can use `on.exit()` to implement a simple version of `capture.output()`.

```{r}
capture.output2 <- function(code) {
  temp <- tempfile()
  on.exit(file.remove(temp), add = TRUE, after = TRUE)

  sink(temp)
  on.exit(sink(), add = TRUE, after = TRUE)

  force(code)
  readLines(temp)
}
capture.output2(cat("a", "b", "c", sep = "\n"))
#> [1] "a" "b" "c"
```

Compare `capture.output()` to `capture.output2()`. How do the functions differ? What features have I removed to make the key ideas easier to see? How have I rewritten the key ideas so they're easier to understand?

>[]{.answer}

## 6.8 Function Forms


### 6.8.1 Rewriting to prefix form


### 6.8.2 Prefix form


### 6.8.3 Infix functions


### 6.8.4 Replacement functions


### 6.8.5 Special forms


### 6.8.6 Exercises

1.    Rewrite the following code snippets into prefix form:

```{r}
#| eval: false

1 + 2 + 3

1 + (2 + 3)

if (length(x) <= 5) x[[5]] else x[[n]]
```


```{r}

```


2.    Clarify the following list of odd function calls:

```{r}
x <- sample(replace = TRUE, 20, x = c(1:10, NA))
y <- runif(min = 0, max = 1, 20)
cor(m = "k", y = y, u = "p", x = x)
```

>[]{.answer}

3.    Explain why the following code fails:

```{r}
#| eval: false

modify(get("x"), 1) <- 10
#> Error: target of assignment expands to non-language object
```

>[]{.answer}

4.    Create a replacement function that modifies a random location in a vector.


```{r}

```

>[]{.answer}

5.    Write your own version of `+` that pastes its inputs together if they are character vectors but behaves as usual otherwise. In other words, make this code work:

```{r}
#| eval: false

1 + 2
#> [1] 3

"a" + "b"
#> [1] "ab"
```

>[]{.answer}

6.    Create a list of all the replacement functions found in the base package. Which ones are primitive functions? (Hint: use `apropos()`.)


>[]{.answer}

7.    What are valid names for user-created infix functions?

>[]{.answer}

8.    Create an infix `xor()` operator.

```{r}

```


9.    Create infix versions of the set functions `intersect()`, `union()`, and `setdiff()`. You might call them `%n%`, `%u%`, and `%/%` to match conventions from mathematics.


```{r}

```

