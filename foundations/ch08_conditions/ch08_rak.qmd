---
title: "Chapter 8: Conditions"
format: 
  html:
    toc: true
    embed-resources: true
engine: knitr
code-overflow: wrap
editor: source
---

```{r libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(purrr)
librarian::shelf(rlang)

```



```{scss custom-themes, echo=FALSE}

.answer { 
  color: #475286FF;
  font-weight: bolder;
}

.question {
  color: #4C9AC4FF;
  font-style: italic;
}

.todo {
  color: #B53737FF;
  font-weight: bolder;
}
```


# 8.1 Intro

## Notes


- "I also found it helpful to look through the underlying C code that implements these ideas" LOLOL


# 8.2 Signalling conditions

## Notes

- you can signal three conditions:

    - Errors (`stop()`): no way for a function to continue; execution must stop
    
        - helpful to set `call. = FALSE` to avoide call, or use `rlang::abort()`
    
    - Warnings (`warning()`): something has gone wrong/unexpected; function could at least partially recover
    
        - you can turn warnings into errors with `options(warn = 2)` - helpful to debug with `traceback()`
        
        - also `rlang::warn()`
        
        - use with restraint, may be better to throw an error
    
    - Messages (`message()`): tells a user some action has been performed
    
        - use when a default argument requires non-trivial computation, functions called primarily for side-effects, running a long process with no immediate output (or use a progress bar), when your package is loaded to dispaly a startup message
        
        - good to have a way to suppress messages in functions 
        
        - use `cat()` when primary role is to print to console, and `message()` when primary purpose of function is something else
    
- a final condition, an interrupt, can only be generated interactively when user has pressed something like escape


## Exercises

1. Write a wrapper around `file.remove()` that throws an error if the file to be deleted does not exist.

```{r}

file.remove.err <- function(x, ... = NULL){
  if(!exists(x)){
    stop("The file to be deleted does not exist")
  }
  
  if(exists(x)){
    file.remove(x)
  }
}

```

> []{.answer}

2. What does the `appendLF` argument to `message()` do? How is it related to `cat()`?

> [It determines whether or not messages that are character strings have newlines appended, with the default being FALSE. `cat` has similar arguments, `fill` that determines how output is broken into lines.]{.answer}


# 8.3 Ignoring Conditions

## Notes

- use assignment inside of `try` to allow you to define a default value to use if code doesn't succeed

# 8.4 Handling conditions

## Notes

- condition handlers allow users to override or supplement the default behavior of messages, warnings and errors temporarily

- `tryCatch()` defines exiting handlers so is more useful for errors and interrupts

- `withCallingHandlers()` defines calling handlers, after condition is captured it returns to context where condition was signaled and is better for non-errors

- condition objects are created implicitly when you signal a condition, but become explicity inside handler

     - have a class attribute so they are S3 objects
     
     - lists with two elements: message and call

[how does the code below work]{.question}

- i see, this is a `message` not an `error`

```{r}
tryCatch(
  message = function(cnd) "There",
  {
    message("Here")
    stop("This code is never run!")
  }
)
#> [1] "There"
```

[Clarify this: "The protected code is evaluated in the environment of `tryCatch()`, but the handler code is not, because the handlers are functions. This is important to remember if youâ€™re trying to modify objects in the parent environment."]{.question}

- `tryCatch` called with a single argument, the condition (`cnd`) and can have another argument, `finally` that behaves like `on.exit()`

- [I don't understand how the muffle condition works]{.question}

## Exercises 

1. What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what's the difference between these two objects? Read the help for ?abort to learn more.

```{r}
catch_cnd(stop("An error"))
catch_cnd(abort("An error"))
```
> [the abort function contains a traceback/call tree in addition to the condition]{.answer}


2. Predict the results of the following code

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```


>["error"]{.answer}
>[NULL]{.answer}
>["warning"]{.answer}
>["message" because it exits after the first catch?]{.answer}

3. Explain the results of running this code:

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
#> b
#> a
#> b
#> c
```

>[the first calling handler displays its message when it detects a message in the nested calling handler, and then the message of the nested calling handler emerges, and since there is a second message in the code it triggers the first one again followed by the last message `c`.]{.answer}

4. Read the source code for `catch_cnd()` and explain how it works.

>[It checks a list of handlers using `tryCatch` to return the first condition flagged?]{.answer}


5. How could you rewrite `show_condition()` to use a single handler?

>[you could probably use `catch_cnd()` and access the attributes in it to pull out which type of condition is thrown by the code]{.answer}

```{r}
show_condition2 <- function(code) {
  obj <- catch_cnd(code)
  if(!is.null(obj)){
     tmp_attr <- attr(obj, "class")[2]
  } else {
    tmp_attr <- obj
  }
  return(tmp_attr)
}

show_condition2(stop("!"))
show_condition2(10)
show_condition2(warning("?!"))
show_condition2({
  10
  message("?")
  warning("?!")
})

```


# 8.5 Custom Conditions

## Notes

- you can create custom conditions with additional metadata to make them more useful

- supposedly these are easier to program with 

- put most specific handler first when using tryCatch() with multiple handlers and custom classes - the first handler to match will be called not the best match

## Exercises

1. Inside a package, it's occasionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with requireNamespace("pkg", quietly = FALSE)) and if not, throws a custom condition that includes the package name in the metadata.

```{r}

abort_not_installed <- function(arg){
  msg <- glue::glue("package `{arg}` is not installed")
  
  abort("error_not_installed",
        message = msg,
        name = arg)
}

check_package <- function(name){
  if(!is.character(name)){
    stop("name must be a character vector")
  }
  
  if(!requireNamespace(name, quietly = FALSE)){
    abort_not_installed(name)
  } 
  
  if(requireNamespace(name, quietly = FALSE)){
    print("Package is installed.")
  }
  
}
```


>[see code]{.answer}

2. Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

>[You can create a custom condition with specific metadata that can be accessed so that the output is predictable.]{.answer}

# 8.6 Applications

## Notes

Use conditions to:

- return a particular value if code fails

- return a value if successful and different value if it fails

- record conditions for future inspection

- to signal a condition that doesn't inherit from `message`, `warning`, or `error`

## Exercises

1. Create `suppressConditions()` that works like `suppressMessages()` and `suppressWarnings()` but suppresses everything. Think carefully about how you should handle errors.

>[]{.answer}

2.Compare the following two implementations of `message2error()`. What is the main advantage of `withCallingHandlers()` in this scenario? (Hint: look carefully at the traceback.)

```{r}
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}

message2error <- function(code) {
  tryCatch(code, message = function(e) stop(e))
}
```

>[]{.answer}

3. How would you modify the `catch_cnds()` definition if you wanted to recreate the original intermingling of warnings and messages?

>[]{.answer}

4. Why is catching interrupts dangerous? Run this code to find out. 

```{r eval=FALSE}
bottles_of_beer <- function(i = 99) {
  message(
    "There are ", i, " bottles of beer on the wall, ", 
    i, " bottles of beer."
  )
  while(i > 0) {
    tryCatch(
      Sys.sleep(1),
      interrupt = function(err) {
        i <<- i - 1
        if (i > 0) {
          message(
            "Take one down, pass it around, ", i, 
            " bottle", if (i > 1) "s", " of beer on the wall."
          )
        }
      }
    )
  }
  message(
    "No more bottles of beer on the wall, ", 
    "no more bottles of beer."
  )
}
```

>[Because it ]{.answer}
