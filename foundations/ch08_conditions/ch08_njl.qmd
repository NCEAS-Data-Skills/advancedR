
```{r 08-libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(rlang)
```

### 8.1 Introduction

"Conditions" are paired sets of tools that allow function authors to indicate when something unusual is happening. Function authors **signal** conditions with functions like `stop()`, `warning()`, or `message()`. Function users can then handle them with `tryCatch()` or `withCallingHandlers()`.

### 8.2 Signaling Conditions

| **Condition** | **Severity** | **Description** | Function |
|:---:|:---:|:-----------------------------|:---:|
| Error | Most | Indicate that the function _cannot_ continue and execution must stop | `stop()` |
| Warning | Intermediate | Indicate something has gone wrong but the function could at least partially recover | `warning()` |
| Message | Least | Indicate that an action has been taken on the user's behalf but not necessarily a problem | `message()` |
| Interrupt | -- | <u>Only occurs in interactive contexts</u>. Indicates the user has manually escaped an execution | -- |

#### 8.2.1 Errors

By default, errors include the function call where the error occurred. Can be silenced with the `call. = F` argument in `stop()` or by using `rlang::abort()` instead of `stop()` which has this behavior set as the default. Wickham says it is good practice to do this but I think it can be helpful when debugging heavily nested functions to know whether the function the user thinks they called is the one with the error or instead is some deeper/internal function.

Tidyverse style guide has nice [tips on writing informative error messages](https://style.tidyverse.org/error-messages.html).

#### 8.2.2 Warnings

You can have multiple errors on the same function call (while you'd only get the _first_ error). Warnings are sort of nebulous because it can be hard to decide between using one versus using an error/message instead. Wickham suggests the obvious contexts for warnings are when you deprecate a function or when you're reasonably certain you can recover from a problem.

#### 8.2.3 Messages

Messages are used for information purpsoes only. Common cases include:

- When default argument requires substantive computation and you want to tell the user what was done
- When a function is called for side effects but would otherwise be silent
- When a process takes a while and you want to re-assure the user that the function is still working (or you can use a progress bar with `progress`--see [here](https://r-lib.github.io/progress/))
- When a package is first loaded

Generally nice to give a `quiet` argument to the user so there's an easy way of silencing messages if desired.

#### 8.2.4 Exercises

1. Write a wrapper around `file.remove()` that throws an error if the file to be deleted does not exist.

[See below]{.answer}

```{r 08-signal_a1}
file.rm2 <- function(file){
  
  if(file.exists(file) != TRUE)
    stop("Can't find `file`")
  
  file.remove(file)
  
}
```

2. What does the `appendLF` argument to `message()` do? How is it related to `cat()`?

[That argument determines whether a new line should be added to the end of messages returned as character strings. `cat()` only behaves this way if the `fill` argument is `TRUE` or numeric]{.answer}

### 8.3 Ignoring Conditions

Simplest way of handling conditions in R is to ignore them. `try()` ignores errors, `suppressWarnings()` ignores warnings, and `suppressMessages()` ignores messages.

`try()` continues execution of the function after encountering an error though `tryCatch()` is more recommended for debugging purposes.

### 8.4 Handling Conditions

"Condition handlers" let us temporarily override default behaviors of errors/warnings/messages; these include `tryCatch()` and `withCallingHandlers()`. See the below code chunk for an example of their syntax.

```{r 08-handle-syntax}
#| eval: false

tryCatch(
  error = function(cnd) {
    # code to run when error is thrown
  },
  code_to_run_while_handlers_are_active
)

withCallingHandlers(
  warning = function(cnd) {
    # code to run when warning is signalled
  },
  message = function(cnd) {
    # code to run when message is signalled
  },
  code_to_run_while_handlers_are_active
)
```

#### 8.4.1 Condition Objects

When conditions are signaled, they make a 'secret' condition object. Built-in conditions (see 8.5 for custom conditions) are lists with two elements:

1. `message` -- length 1 character vector containing text to display to user. Extractable via `conditionMessage()`
2. `call` -- call which triggered the condition. If the signaler does not include the call (see 8.2), then it will be `NULL`. Extractable via `conditionCall()`

#### 8.4.2 Exiting Handlers

`tryCatch()` creates exiting handlers (typically as a result of error conditions). They are so named because once one is triggered, control is passed to the handler and never returns to the original function code (effectively until the "exit" of the code). 

You can also specify a `finally` argument (within `tryCatch()`) that specifies a non-function block of code to run regardles of whether the original expression succeeds. See below for a syntax example.

```{r 08-handle-exit-syntax}
#| eval: false

path <- tempfile()
tryCatch(
  {
    writeLines("Hi!", path)
    # ...
  },
  finally = {
    # always run
    unlink(path)
  }
)
```

#### 8.4.3 Calling Handlers

`withCallingHandlers()` sets up "calling handlers" where code execution continues normally once the handler returns (as opposed to exit handlers where execution does not return).

_Calling handlers are only useful for their side effects_ because there is nowhere for a hypothetical returned value to be stored.

#### 8.4.4 Call Stacks

See the book for details here (felt very edge case and not sure how I'd summarize it).

#### 8.4.5 Exercises

1. What extra information does the condition generated by `rlang::abort()` contain compared to the condition generated by `stop()` i.e. what's the difference between these two objects? Read the help for `?rlang::abort()` to learn more.




2. Predict the results of evaluating the following code

[]{.answer}

```{r 08-handle_q2}
#| eval: false

show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

show_condition(stop("!"))
show_condition(10)
show_condition(warning("?!"))
show_condition({
  10
  message("?")
  warning("?!")
})
```

3. Explain the results of running this code:

```{r 08-handle_q3}
#| eval: false

withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
#> b
#> a
#> b
#> c
```

4. Read the source code for `catch_cnd()` and explain how it works.


5. How would you rewrite `show_condition()` to use a single handler?



### 8.5 Custom Conditions



### 8.6 Applications





