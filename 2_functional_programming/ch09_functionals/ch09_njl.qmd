
```{r 09-libs}
#| echo: false
#| message: false

# Install/load needed libraries
## install.packages("librarian")
librarian::shelf(purrr)
```

### 9.1 Introduction

A **functional** takes a function as an input and returns a vector as output. Functionals are a less flexible--and thus more predictable--version of a `for` loop.

### 9.2 Hadley's First Funtional: `map`

`map`'s base R equivalent is `lapply`. All `map` variants use the convention that a function's suffix refers to the ouptut of the function (e.g., `map_dbl` returns a double vector).

#### 9.2.1 Producing Atomic Vectors

`map`'s more specific variants produces the same number of outputs as inputs and can't return inappropriate types (_sensu_ "class") of results.

`vapply` is the preferred base R equivalent to `map_*` when you want an atomic vectors. It is more verbose though (e.g., `map_dbl(x, mean, na.rm = T)` **==** `vapply(x, mean, na.rm = T, FUN.VALUE = double(1))`)

#### 9.2.2 Anonymous Functions & Shortcuts

`map` supports in-line anonymous functions (a.k.a. "lamda functions") or you can use a special syntax with `~`.

#### 9.2.3 Passing Arguments with `...`

`map` supports passing bonus arguments to `...`. Essentially, the first argument is `.x` (thing to iterate across), the second is `.f` (function to use on each element of `.x`), and all remaining argument/value pairs are assumed to be arguments of `.f`.

#### 9.2.4 Argument Names

It is kinder to readers of your code to specify _both_ the argument name and its value for any additional arguments passed to `map` (additional as in beyond `.x` and `.f`).

#### 9.2.5 Varying Another Argument

There's no shortcut to varying an argument other than the first when passing to `map` so you'd need to use a lambda function to reorder the arguments as they passed to the function assigned to `.f`.

#### 9.2.6 Exercises

1. Use `as_mapper()` to explore how `purrr` generates anonymous functions for the integer, character, and list helpers. What helper allows you to extract attributes? Read the documentation to find out.


2. `map(1:3, ~ runif(2))` is a useful pattern for generating random numbers, but `map(1:3, runif(2))` is not. Why not? Can you explain why it returns the result that it does?

[The non-shortcut version (i.e., the one lacking `~`) is not actually using the `runif` function and so just returns the integers passed to `.x` in `map`. This is because it is not using either the shortcut or the working non-shortcut syntax that `map` expects. If we revise that option into the non-shortcut syntax it should start working in the same way as the shorcut variant. See below for a demonstration of the approaches]{.answer}

```{r 09-map_q2}
# Shortcut
purrr::map(.x = 1:3, .f = ~ runif(n = 2))

# Useless
purrr::map(.x = 1:3, .f = runif(n = 2))

# Revised non-shortcut
purrr::map(.x = 1:3, .f = function(x) runif(n = 2))
```

3. Use the appropriate `map` function to:

> a. Compute the standard deviation of every column in a numeric data frame.

> b. Compute the standard deviation of every numeric column in a mixed data frame. (Hint: youâ€™ll need to do it in two steps.)

> c. Compute the number of levels for every factor in a data frame.

4. The following code simulates the performance of a t-test for non-normal data. Extract the p-value from each test, then visualise.

```{r 09-map_q4}
#| eval: false

trials <- purrr::map(.x = 1:100, .f = ~ t.test(rpois(10, 10), rpois(7, 10)))
```

5. The following code uses a `map` nested inside another `map` to apply a function to every element of a nested list. Why does it fail, and what do you need to do to make it work?

```{r 09-map_q5}
#| eval: false

x <- list(
  list(1, c(3, 9)),
  list(c(3, 6), 7, c(4, 7, 6))
)

triple <- function(x) x * 3
map(x, map, .f = triple)
#> Error in .f(.x[[i]], ...): unused argument (function (.x, .f, ...)
#> {
#> .f <- as_mapper(.f, ...)
#> .Call(map_impl, environment(), ".x", ".f", "list")
#> })
```

6. Use `map` to fit linear models to the mtcars dataset using the formulas stored in this list:

```{r 09-map_q6}
#| eval: false

formulas <- list(
  mpg ~ disp,
  mpg ~ I(1 / disp),
  mpg ~ disp + wt,
  mpg ~ I(1 / disp) + wt
)
```

7. Fit the model `mpg ~ disp` to each of the bootstrap replicates of mtcars in the list below, then extract the R^2^ of the model fit (Hint: you can compute the R^2^ with `summary`.)

```{r 09-map_q7}
#| eval: false

bootstrap <- function(df) {
  df[sample(nrow(df), replace = TRUE), , drop = FALSE]
}

bootstraps <- purrr::map(.x = 1:10, .f = ~ bootstrap(mtcars))
```

### 9.3 `purrr` Style


### 9.4 `map` Variants

#### 9.4.1 Same Type of Input/Output: `modify`

#### 9.4.2 Two inputs: `map2` & Friends


#### 9.4.3 No outputs: `walk` & Friends


#### 9.4.4 Iterating Over Values & Indices

#### 9.4.5 Any Number of Inputs: `pmap` & Friends


#### 9.4.6 Exercises

### 9.5 `reduce` Family

#### 9.5.1 Basics


#### 9.5.2 Accumulate


#### 9.5.3 Output Types


#### 9.5.4 Multiple Inputs


#### 9.5.5 Map-Reduce


### 9.6 Predicate Functionals

#### 9.6.1 Basics

#### 9.6.2 Map Variants


#### 9.6.3 Exercises


### 9.7 Base Functionals


#### 9.7.1 Matrices & Arrays


#### 9.7.2 Mathematical Concerns


#### 9.7.3 Exercises





